'''Very hacky and definitely NOT the cleanest way to do this.

The implementation of the transformations is as follows:
1) Store all squares as strings
2) Create a dict with all permutations of the 'from' string
3) Dict lookup handles 2x2 and 3x3 permutations. 4x4 strings are
converted to 2x2 squares.

Due to 'even division' rule, 6x6 squares must be broken down into
2x2 squares. Because the 6x6 squares are generated by 4 3x3 squares
and everything was stored as str, this requires a hacky break_4x4_squares
function.

Fortunately, the following iteration creates a square of size 9x9 which
breaks back into 3 3x3 squares.

This means there is a loop from 1 3x3 square -> 9 3x3 squares, which can
be handled by the fractal_art() function with max_range = 3, despite its
weird implementation.

Part 2 is solved by looping over an expanding range of 3x3 squares. It would
 have been nice to store the output of 1 square -> 9 squares with a count of
 every type of square so as not to have to loop over a list containing the
 same square many times but oh well.'''

def reverse(l):
    '''Reverses the order of the list.

    > reverse(['.#.', '..#', '###'])
    # ['###', '..#', '.#.']
    '''
    return l[::-1]

def flip(l):
    '''Reverses the order of the components of the list.

    > flip(['.#.', '..#', '###'])
    # ['.#.', '#..', '###']
    '''
    return [s[::-1] for s in l]

def slice(s):
    '''Visual example:
        .#.           ..#
        ..#    ->     #.#
        ###           .##

    slice(['.#.', '..#', '###'])
    # ['..#', '#.#', '.##']
    '''
    sliced = []
    for r in range(len(s)):
        temp = ''.join([t[r] for t in s])
        sliced.append(temp)
    return sliced

def get_facets(s):
    '''Return all flips / reversals / slices of a str.

    > get_facets('.#./..#/###')
    # ['.#./..#/###', '###/..#/.#.', '.#./#../###', '###/#../.#.']

    :param s: str
    :return: list[str]
    '''
    s0 = s.split('/')
    s1 = reverse(s0)
    s2 = slice(s0)
    s3 = slice(s1)
    s4 = reverse(s2)
    s5 = reverse(s3)
    s6, s7 = flip(s0), flip(s1)
    final = list(map('/'.join, [s0, s1, s2, s3, s4, s5, s6, s7]))
    return final

def parse_input(line):
    '''Takes a formatted string and returns a tuple of values.
    old_sq_facets contains all the flips and rotations of the
    square at the left of '=>'. new_sq is the square those rotations
    are being turned into by the program.

    > line = '../.# => ##./#../...'
    > parse_input(line)
    # (['../.#', '.#/..', '../#.', '#./..'], '##./#../...')

    :param line:
    :return:
    '''
    old_sq, new_sq = line.split(' => ')
    old_sq_facets = get_facets(old_sq)
    return old_sq_facets, new_sq

def create_trans_dict(_input):
    '''Turns _input into a dictionary of transformations.
    Keys and values of the dict are strings representing squares,
    like '../.#'.

    :param _input: list of str formatted like '../.# => ##./#../...'
    :return: dict
    '''
    d = {}

    for line in _input:
        old_sq_facets, new_sq = parse_input(line)
        for facet in old_sq_facets: d[facet] = new_sq

    return d

def break_4x4_squares(s):
    '''Breaks a 4x4 square into 4 2x2 squares.
    See visual representation below:
        #.|.#
        ..|..
        --+--
        ..|..
        #.|.#

    > break_4x4_squares('#..#/..../..../#..#')
    # ['#./..', '.#/..', '../#.', '../.#']

    :param s: str representing a 4x4 square
    :return: list of str representing 2x2 squares
    '''
    list_s = s.split('/')
    s0 = [list_s[0][:2], list_s[1][:2]]
    s1 = [list_s[0][2:], list_s[1][2:]]
    s2 = [list_s[2][:2], list_s[3][:2]]
    s3 = [list_s[2][2:], list_s[3][2:]]
    final = list(map('/'.join, [s0, s1, s2, s3]))
    return final

def break_6x6_squares(temp):
    '''Converts representation of 6x6 square as list of 3x3 squares
    to list of 2x2 squares.

    > temp = ['##./###/#.#', '###/.#./###', '###/.#./###', '#.#/..#/#..']
    > break_6x6_squares(temp)
    # ['#./..',
    #  '##/##',
    #  '.#/.#',
    #  '#./##',
    #  '.#/.#',
    #  '##/#.',
    #  '##/#.',
    #  '##/##',
    #  '##/.#']

    :param temp: list[str], 6x6 square represented by 3x3 squares
    :return: list[str], 6x6 squares representing 2x2 squares
    '''
    top1 = temp[0].split('/')[0] + temp[1].split('/')[0]
    top2 = temp[0].split('/')[1] + temp[1].split('/')[1]
    top3 = temp[0].split('/')[2] + temp[1].split('/')[2]
    top4 = temp[2].split('/')[0] + temp[3].split('/')[0]
    top5 = temp[2].split('/')[1] + temp[3].split('/')[1]
    top6 = temp[2].split('/')[2] + temp[3].split('/')[2]

    s0 = top1[:2] + '/' + top2[:2]
    s1 = top1[2:4] + '/' + top2[2:4]
    s2 = top1[4:] + '/' + top2[4:]
    s3 = top3[:2] + '/' + top4[:2]
    s4 = top3[2:4] + '/' + top4[2:4]
    s5 = top3[4:] + '/' + top4[4:]
    s6 = top5[:2] + '/' + top6[:2]
    s7 = top5[2:4] + '/' + top6[2:4]
    s8 = top5[4:] + '/' + top6[4:]

    return [s0, s1, s2, s3, s4, s5, s6, s7, s8]

def fractal_art(squares, d, max_range):
    for r in range(max_range):
        new_squares = []

        if r == 2:  # hacky way to deal with size 12 - initial impl broke it into 3x3 squares
            new_vals = break_6x6_squares(squares)
            squares = new_vals

        for s in squares:
            new_val = d[s]
            if len(new_val) == 19: # dealing w 4x4 square
                new_vals = break_4x4_squares(new_val)
                new_squares.extend(new_vals)
            else: # 3x3 or 4x4
                new_squares.append(d[s])

        squares = new_squares

    return squares, sum([s.count('#') for s in squares])

def run(d, part):
    squares = ['.#./..#/###']  # initial square

    if part == 1:
        squares, sol1 = fractal_art(squares, d, 5)  # 205
        return sol1
    else:
        for n in range(0, 18, 3):
            new_squares = []

            for s in squares:
                temp, sol2 = fractal_art([s], d, 3)
                new_squares.extend(temp)

            squares = new_squares

        return sum([s.count('#') for s in new_squares])

if __name__ == '__main__':
    _input = open("2017/aoc_21.txt").read().splitlines()
    d = create_trans_dict(_input)

    sol1 = run(d, part=1)  # 205
    sol2 = run(d, part=2)  # 3389823

    print(f'PART 1: {sol1} \n PART 2: {sol2}')

